# Архитектурные правила

### Общие принципы
1. Зона ответственности сущности ограничена её слоем — во View (компоненты, ViewModel) не пишут расчёты, правила предметной области и работу с данными; такая логика живёт в сервисах.
2. Зависимости идут только вниз по слоям — ViewModel использует Service и инфраструктуру (плагины); **сервис не инжектирует другие сервисы**, только инфраструктуру (логгер, модалки, настройки, хранилище и т.д.).
3. Универсальность растёт сверху вниз — ViewModel привязаны к фиче, сервисы — к домену, инфраструктура максимально переиспользуема.

### View Layer
4. Запрещено использовать родительские или дочерние ViewModel внутри Widget — внутри виджета может использоваться только его собственная ViewModel.
5. Widget не должен зависеть от окружения — виджет обязан иметь возможность встраиваться в любое место без дополнительных обвязок (контекст React, специально подготовленные сервисы).
6. Component не должен содержать бизнес-логику.
7. ViewModel не должна содержать бизнес-логику — ViewModel может хранить только данные, влияющие на UI (состояния чекбоксов, инпутов), но не бизнес-логику. Бизнес-логика описывается в Domain Layer.
8. ViewModel может содержать подмодели — VM могут содержать в себе другие SubViewModel.
9. Component может обращаться только к своему ViewModel (через хук `useXxxModel()`; реактивность — MobX `observer`). Во вьюшке использовать деструктуризацию результата хука; методы ViewModel, передаваемые в компоненты, объявлять стрелочными функциями поля класса. Детали и примеры — в [Стандарты написания кода](../.cursor/rules/coding-standards.md) (раздел «MobX компоненты»).

### Domain Layer
Domain Layer — слой бизнес-логики; в нём **продуктовые сервисы** (переиспользуемая логика, не привязанная к UI).
10. Service должен иметь чётко определённую ответственность — сервис инкапсулирует переиспользуемый функционал.
11. **Service не инжектирует другие сервисы** — только инфраструктуру (плагины) через DI. Прямые импорты сервисов в сервисах запрещены. Если сервису нужны данные другого домена: либо их передают аргументом метода (ViewModel резолвит оба сервиса и передаёт результат одного в вызов другого), либо общую логику выносят в инфраструктурный сервис/плагин, от которого зависят оба.

### Platform Layer (инфраструктура / плагины)
Переиспользуемые кросс-доменные возможности: логгер, модальные окна, настройки приложения, хранилище, аналитика и т.д. Сервисы домена могут зависеть от них; они не зависят от продуктовых сервисов.
12. Плагин (инфраструктурный сервис) имеет одну зону ответственности и по возможности абстрактный интерфейс — для подмены в тестах и изоляции реализации.
13. **Плагины и сервисы разнесены по директориям**: продуктовые сервисы — в `src/services/`, плагины — в `src/plugins/`. Импорт плагинов — через алиас `@plugins` (barrel).
14. **Плагин должен иметь суффикс "Plugin"** — например: LoggerPlugin, GameSettingsPlugin.

### DI Container
Подробно с примерами — в [Стандарты написания кода](../.cursor/rules/coding-standards.md) (раздел «DI») и [Организация файлов](../.cursor/rules/file-organization.md).

15. Время жизни VM и не глобальных сервисов ограничено маунтом/размаунтом контейнера — при размонтировании контейнера все сущности должны быть очищены.

**Циклические зависимости.** При нарушении правила «сервис не инжектирует сервисы» возникает цикл (A ↔ B) и ReferenceError при инициализации. Решение: координация через ViewModel или вынос общей логики в инфраструктурный сервис/плагин; сервисы остаются без взаимных зависимостей.

### Нейминг
16. Service должен иметь постфикс "Service" — например: CityService.
17. Plugin должен иметь постфикс "Plugin" — например: LoggerPlugin, GameSettingsPlugin.
18. ViewModel должен иметь постфикс "Model" — например: CityModel.
19. Widget должен иметь постфикс "Widget" — например: CityWidget.
20. Page должен иметь постфикс "Page" — например: CityPage.
21. Название ViewModel должно перекликаться с названием Widget — например: CityWidget → CityModel.
